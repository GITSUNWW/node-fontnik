        -:    0:Source:/home/travis/build/GITSUNWW/node-fontnik/mason_packages/.link/include/agg/agg_basics.h
        -:    0:Graph:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcno
        -:    0:Data:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://----------------------------------------------------------------------------
        -:    2:// Anti-Grain Geometry - Version 2.4
        -:    3:// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
        -:    4://
        -:    5:// Permission to copy, use, modify, sell and distribute this software
        -:    6:// is granted provided this copyright notice appears in all copies.
        -:    7:// This software is provided "as is" without express or implied
        -:    8:// warranty, and with no claim as to its suitability for any purpose.
        -:    9://
        -:   10://----------------------------------------------------------------------------
        -:   11:// Contact: mcseem@antigrain.com
        -:   12://          mcseemagg@yahoo.com
        -:   13://          http://www.antigrain.com
        -:   14://----------------------------------------------------------------------------
        -:   15:
        -:   16:#ifndef AGG_BASICS_INCLUDED
        -:   17:#define AGG_BASICS_INCLUDED
        -:   18:
        -:   19:#include <cmath>
        -:   20:#include "agg_config.h"
        -:   21:
        -:   22://---------------------------------------------------------AGG_CUSTOM_ALLOCATOR
        -:   23:#ifdef AGG_CUSTOM_ALLOCATOR
        -:   24:#include "agg_allocator.h"
        -:   25:#else
        -:   26:namespace agg_fontnik
        -:   27:{
        -:   28:    // The policy of all AGG containers and memory allocation strategy
        -:   29:    // in general is that no allocated data requires explicit construction.
        -:   30:    // It means that the allocator can be really simple; you can even
        -:   31:    // replace new/delete to malloc/free. The constructors and destructors
        -:   32:    // won't be called in this case, however everything will remain working.
        -:   33:    // The second argument of deallocate() is the size of the allocated
        -:   34:    // block. You can use this information if you wish.
        -:   35:    //------------------------------------------------------------pod_allocator
        -:   36:    template<class T> struct pod_allocator
        -:   37:    {
        -:   38:        //static T*   allocate(unsigned num)       { return static_cast<T*>(::operator new(sizeof(T)*num));}
        -:   39:        //static void deallocate(T* ptr, unsigned) { ::operator delete(ptr) ;}
function _ZN11agg_fontnik13pod_allocatorIPNS_10point_baseIdEEE8allocateEj called 21910 returned 100% blocks executed 100%
function _ZN11agg_fontnik13pod_allocatorINS_10point_baseIdEEE8allocateEj called 21910 returned 100% blocks executed 75%
  1424147:   40:        static T*   allocate(unsigned num)       { return new T [num]; }
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 98%
branch  5 taken 2%
function _ZN11agg_fontnik13pod_allocatorINS_10point_baseIdEEE10deallocateEPS2_j called 21910 returned 100% blocks executed 100%
function _ZN11agg_fontnik13pod_allocatorIPNS_10point_baseIdEEE10deallocateEPS3_j called 21910 returned 100% blocks executed 100%
    43820:   41:        static void deallocate(T* ptr, unsigned) { delete [] ptr;      }
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:   42:    };
        -:   43:
        -:   44:    // Single object allocator. It's also can be replaced with your custom
        -:   45:    // allocator. The difference is that it can only allocate a single
        -:   46:    // object and the constructor and destructor must be called.
        -:   47:    // In AGG there is no need to allocate an array of objects with
        -:   48:    // calling their constructors (only single ones). So that, if you
        -:   49:    // replace these new/delete to malloc/free make sure that the in-place
        -:   50:    // new is called and take care of calling the destructor too.
        -:   51:    //------------------------------------------------------------obj_allocator
        -:   52:    template<class T> struct obj_allocator
        -:   53:    {
        -:   54:        static T*   allocate()         { return new T; }
        -:   55:        static void deallocate(T* ptr) { delete ptr;   }
        -:   56:    };
        -:   57:}
        -:   58:#endif
        -:   59:
        -:   60:
        -:   61://-------------------------------------------------------- Default basic types
        -:   62://
        -:   63:// If the compiler has different capacity of the basic types you can redefine
        -:   64:// them via the compiler command line or by generating agg_config.h that is
        -:   65:// empty by default.
        -:   66://
        -:   67:#ifndef AGG_INT8
        -:   68:#define AGG_INT8 signed char
        -:   69:#endif
        -:   70:
        -:   71:#ifndef AGG_INT8U
        -:   72:#define AGG_INT8U unsigned char
        -:   73:#endif
        -:   74:
        -:   75:#ifndef AGG_INT16
        -:   76:#define AGG_INT16 short
        -:   77:#endif
        -:   78:
        -:   79:#ifndef AGG_INT16U
        -:   80:#define AGG_INT16U unsigned short
        -:   81:#endif
        -:   82:
        -:   83:#ifndef AGG_INT32
        -:   84:#define AGG_INT32 int
        -:   85:#endif
        -:   86:
        -:   87:#ifndef AGG_INT32U
        -:   88:#define AGG_INT32U unsigned
        -:   89:#endif
        -:   90:
        -:   91:#ifndef AGG_INT64
        -:   92:#if defined(_MSC_VER) || defined(__BORLANDC__)
        -:   93:#define AGG_INT64 signed __int64
        -:   94:#else
        -:   95:#define AGG_INT64 signed long long
        -:   96:#endif
        -:   97:#endif
        -:   98:
        -:   99:#ifndef AGG_INT64U
        -:  100:#if defined(_MSC_VER) || defined(__BORLANDC__)
        -:  101:#define AGG_INT64U unsigned __int64
        -:  102:#else
        -:  103:#define AGG_INT64U unsigned long long
        -:  104:#endif
        -:  105:#endif
        -:  106:
        -:  107://------------------------------------------------ Some fixes for MS Visual C++
        -:  108:#if defined(_MSC_VER)
        -:  109:#pragma warning(disable:4786) // Identifier was truncated...
        -:  110:#endif
        -:  111:
        -:  112:#if defined(_MSC_VER)
        -:  113:#define AGG_INLINE __forceinline
        -:  114:#else
        -:  115:#define AGG_INLINE inline
        -:  116:#endif
        -:  117:
        -:  118:namespace agg_fontnik
        -:  119:{
        -:  120:    //-------------------------------------------------------------------------
        -:  121:    typedef AGG_INT8   int8;         //----int8
        -:  122:    typedef AGG_INT8U  int8u;        //----int8u
        -:  123:    typedef AGG_INT16  int16;        //----int16
        -:  124:    typedef AGG_INT16U int16u;       //----int16u
        -:  125:    typedef AGG_INT32  int32;        //----int32
        -:  126:    typedef AGG_INT32U int32u;       //----int32u
        -:  127:    typedef AGG_INT64  int64;        //----int64
        -:  128:    typedef AGG_INT64U int64u;       //----int64u
        -:  129:
        -:  130:#if defined(AGG_FISTP)
        -:  131:#pragma warning(push)
        -:  132:#pragma warning(disable : 4035) //Disable warning "no return value"
        -:  133:    AGG_INLINE int iround(double v)              //-------iround
        -:  134:    {
        -:  135:        int t;
        -:  136:        __asm fld   qword ptr [v]
        -:  137:        __asm fistp dword ptr [t]
        -:  138:        __asm mov eax, dword ptr [t]
        -:  139:    }
        -:  140:    AGG_INLINE unsigned uround(double v)         //-------uround
        -:  141:    {
        -:  142:        unsigned t;
        -:  143:        __asm fld   qword ptr [v]
        -:  144:        __asm fistp dword ptr [t]
        -:  145:        __asm mov eax, dword ptr [t]
        -:  146:    }
        -:  147:#pragma warning(pop)
        -:  148:    AGG_INLINE unsigned ufloor(double v)         //-------ufloor
        -:  149:    {
        -:  150:        return unsigned(floor(v));
        -:  151:    }
        -:  152:    AGG_INLINE unsigned uceil(double v)          //--------uceil
        -:  153:    {
        -:  154:        return unsigned(ceil(v));
        -:  155:    }
        -:  156:#elif defined(AGG_QIFIST)
        -:  157:    AGG_INLINE int iround(double v)
        -:  158:    {
        -:  159:        return int(v);
        -:  160:    }
        -:  161:    AGG_INLINE int uround(double v)
        -:  162:    {
        -:  163:        return unsigned(v);
        -:  164:    }
        -:  165:    AGG_INLINE unsigned ufloor(double v)
        -:  166:    {
        -:  167:        return unsigned(floor(v));
        -:  168:    }
        -:  169:    AGG_INLINE unsigned uceil(double v)
        -:  170:    {
        -:  171:        return unsigned(ceil(v));
        -:  172:    }
        -:  173:#else
        -:  174:    AGG_INLINE int iround(double v)
        -:  175:    {
        -:  176:        return int((v < 0.0) ? v - 0.5 : v + 0.5);
        -:  177:    }
function _ZN11agg_fontnik6uroundEd called 0 returned 0% blocks executed 0%
    #####:  178:    AGG_INLINE int uround(double v)
        -:  179:    {
    #####:  180:        return unsigned(v + 0.5);
        -:  181:    }
        -:  182:    AGG_INLINE unsigned ufloor(double v)
        -:  183:    {
        -:  184:        return unsigned(v);
        -:  185:    }
        -:  186:    AGG_INLINE unsigned uceil(double v)
        -:  187:    {
        -:  188:        return unsigned(ceil(v));
        -:  189:    }
        -:  190:#endif
        -:  191:
        -:  192:    //---------------------------------------------------------------saturation
        -:  193:    template<int Limit> struct saturation
        -:  194:    {
        -:  195:        AGG_INLINE static int iround(double v)
        -:  196:        {
        -:  197:            if(v < double(-Limit)) return -Limit;
        -:  198:            if(v > double( Limit)) return  Limit;
        -:  199:            return agg_fontnik::iround(v);
        -:  200:        }
        -:  201:    };
        -:  202:
        -:  203:    //------------------------------------------------------------------mul_one
        -:  204:    template<unsigned Shift> struct mul_one
        -:  205:    {
        -:  206:        AGG_INLINE static unsigned mul(unsigned a, unsigned b)
        -:  207:        {
        -:  208:            unsigned q = a * b + (1 << (Shift-1));
        -:  209:            return (q + (q >> Shift)) >> Shift;
        -:  210:        }
        -:  211:    };
        -:  212:
        -:  213:    //-------------------------------------------------------------------------
        -:  214:    typedef unsigned char cover_type;    //----cover_type
        -:  215:    enum cover_scale_e
        -:  216:    {
        -:  217:        cover_shift = 8,                 //----cover_shift
        -:  218:        cover_size  = 1 << cover_shift,  //----cover_size
        -:  219:        cover_mask  = cover_size - 1,    //----cover_mask
        -:  220:        cover_none  = 0,                 //----cover_none
        -:  221:        cover_full  = cover_mask         //----cover_full
        -:  222:    };
        -:  223:
        -:  224:    //----------------------------------------------------poly_subpixel_scale_e
        -:  225:    // These constants determine the subpixel accuracy, to be more precise,
        -:  226:    // the number of bits of the fractional part of the coordinates.
        -:  227:    // The possible coordinate capacity in bits can be calculated by formula:
        -:  228:    // sizeof(int) * 8 - poly_subpixel_shift, i.e, for 32-bit integers and
        -:  229:    // 8-bits fractional part the capacity is 24 bits.
        -:  230:    enum poly_subpixel_scale_e
        -:  231:    {
        -:  232:        poly_subpixel_shift = 8,                      //----poly_subpixel_shift
        -:  233:        poly_subpixel_scale = 1<<poly_subpixel_shift, //----poly_subpixel_scale
        -:  234:        poly_subpixel_mask  = poly_subpixel_scale-1  //----poly_subpixel_mask
        -:  235:    };
        -:  236:
        -:  237:    //----------------------------------------------------------filling_rule_e
        -:  238:    enum filling_rule_e
        -:  239:    {
        -:  240:        fill_non_zero,
        -:  241:        fill_even_odd
        -:  242:    };
        -:  243:
        -:  244:    //-----------------------------------------------------------------------pi
        -:  245:    const double pi = 3.14159265358979323846;
        -:  246:
        -:  247:    //------------------------------------------------------------------deg2rad
        -:  248:    inline double deg2rad(double deg)
        -:  249:    {
        -:  250:        return deg * pi / 180.0;
        -:  251:    }
        -:  252:
        -:  253:    //------------------------------------------------------------------rad2deg
        -:  254:    inline double rad2deg(double rad)
        -:  255:    {
        -:  256:        return rad * 180.0 / pi;
        -:  257:    }
        -:  258:
        -:  259:    //----------------------------------------------------------------rect_base
        -:  260:    template<class T> struct rect_base
        -:  261:    {
        -:  262:        typedef T            value_type;
        -:  263:        typedef rect_base<T> self_type;
        -:  264:        T x1, y1, x2, y2;
        -:  265:
        -:  266:        rect_base() {}
        -:  267:        rect_base(T x1_, T y1_, T x2_, T y2_) :
        -:  268:            x1(x1_), y1(y1_), x2(x2_), y2(y2_) {}
        -:  269:
        -:  270:        void init(T x1_, T y1_, T x2_, T y2_)
        -:  271:        {
        -:  272:            x1 = x1_; y1 = y1_; x2 = x2_; y2 = y2_;
        -:  273:        }
        -:  274:
        -:  275:        const self_type& normalize()
        -:  276:        {
        -:  277:            T t;
        -:  278:            if(x1 > x2) { t = x1; x1 = x2; x2 = t; }
        -:  279:            if(y1 > y2) { t = y1; y1 = y2; y2 = t; }
        -:  280:            return *this;
        -:  281:        }
        -:  282:
        -:  283:        bool clip(const self_type& r)
        -:  284:        {
        -:  285:            if(x2 > r.x2) x2 = r.x2;
        -:  286:            if(y2 > r.y2) y2 = r.y2;
        -:  287:            if(x1 < r.x1) x1 = r.x1;
        -:  288:            if(y1 < r.y1) y1 = r.y1;
        -:  289:            return x1 <= x2 && y1 <= y2;
        -:  290:        }
        -:  291:
        -:  292:        bool is_valid() const
        -:  293:        {
        -:  294:            return x1 <= x2 && y1 <= y2;
        -:  295:        }
        -:  296:
        -:  297:        bool hit_test(T x, T y) const
        -:  298:        {
        -:  299:            return (x >= x1 && x <= x2 && y >= y1 && y <= y2);
        -:  300:        }
        -:  301:    };
        -:  302:
        -:  303:    //-----------------------------------------------------intersect_rectangles
        -:  304:    template<class Rect>
        -:  305:    inline Rect intersect_rectangles(const Rect& r1, const Rect& r2)
        -:  306:    {
        -:  307:        Rect r = r1;
        -:  308:
        -:  309:        // First process x2,y2 because the other order
        -:  310:        // results in Internal Compiler Error under
        -:  311:        // Microsoft Visual C++ .NET 2003 69462-335-0000007-18038 in
        -:  312:        // case of "Maximize Speed" optimization option.
        -:  313:        //-----------------
        -:  314:        if(r.x2 > r2.x2) r.x2 = r2.x2;
        -:  315:        if(r.y2 > r2.y2) r.y2 = r2.y2;
        -:  316:        if(r.x1 < r2.x1) r.x1 = r2.x1;
        -:  317:        if(r.y1 < r2.y1) r.y1 = r2.y1;
        -:  318:        return r;
        -:  319:    }
        -:  320:
        -:  321:
        -:  322:    //---------------------------------------------------------unite_rectangles
        -:  323:    template<class Rect>
        -:  324:    inline Rect unite_rectangles(const Rect& r1, const Rect& r2)
        -:  325:    {
        -:  326:        Rect r = r1;
        -:  327:        if(r.x2 < r2.x2) r.x2 = r2.x2;
        -:  328:        if(r.y2 < r2.y2) r.y2 = r2.y2;
        -:  329:        if(r.x1 > r2.x1) r.x1 = r2.x1;
        -:  330:        if(r.y1 > r2.y1) r.y1 = r2.y1;
        -:  331:        return r;
        -:  332:    }
        -:  333:
        -:  334:    typedef rect_base<int>    rect_i; //----rect_i
        -:  335:    typedef rect_base<float>  rect_f; //----rect_f
        -:  336:    typedef rect_base<double> rect_d; //----rect_d
        -:  337:
        -:  338:    //---------------------------------------------------------path_commands_e
        -:  339:    enum path_commands_e
        -:  340:    {
        -:  341:        path_cmd_stop     = 0,        //----path_cmd_stop
        -:  342:        path_cmd_move_to  = 1,        //----path_cmd_move_to
        -:  343:        path_cmd_line_to  = 2,        //----path_cmd_line_to
        -:  344:        path_cmd_curve3   = 3,        //----path_cmd_curve3
        -:  345:        path_cmd_curve4   = 4,        //----path_cmd_curve4
        -:  346:        path_cmd_curveN   = 5,        //----path_cmd_curveN
        -:  347:        path_cmd_catrom   = 6,        //----path_cmd_catrom
        -:  348:        path_cmd_ubspline = 7,        //----path_cmd_ubspline
        -:  349:        path_cmd_end_poly = 0x0F,     //----path_cmd_end_poly
        -:  350:        path_cmd_mask     = 0x0F      //----path_cmd_mask
        -:  351:    };
        -:  352:
        -:  353:    //------------------------------------------------------------path_flags_e
        -:  354:    enum path_flags_e
        -:  355:    {
        -:  356:        path_flags_none  = 0,         //----path_flags_none
        -:  357:        path_flags_ccw   = 0x10,      //----path_flags_ccw
        -:  358:        path_flags_cw    = 0x20,      //----path_flags_cw
        -:  359:        path_flags_close = 0x40,      //----path_flags_close
        -:  360:        path_flags_mask  = 0xF0       //----path_flags_mask
        -:  361:    };
        -:  362:
        -:  363:    //---------------------------------------------------------------is_vertex
        -:  364:    inline bool is_vertex(unsigned c)
        -:  365:    {
        -:  366:        return c >= path_cmd_move_to && c < path_cmd_end_poly;
        -:  367:    }
        -:  368:
        -:  369:    //--------------------------------------------------------------is_drawing
        -:  370:    inline bool is_drawing(unsigned c)
        -:  371:    {
        -:  372:        return c >= path_cmd_line_to && c < path_cmd_end_poly;
        -:  373:    }
        -:  374:
        -:  375:    //-----------------------------------------------------------------is_stop
        -:  376:    inline bool is_stop(unsigned c)
        -:  377:    {
        -:  378:        return c == path_cmd_stop;
        -:  379:    }
        -:  380:
        -:  381:    //--------------------------------------------------------------is_move_to
        -:  382:    inline bool is_move_to(unsigned c)
        -:  383:    {
        -:  384:        return c == path_cmd_move_to;
        -:  385:    }
        -:  386:
        -:  387:    //--------------------------------------------------------------is_line_to
        -:  388:    inline bool is_line_to(unsigned c)
        -:  389:    {
        -:  390:        return c == path_cmd_line_to;
        -:  391:    }
        -:  392:
        -:  393:    //----------------------------------------------------------------is_curve
        -:  394:    inline bool is_curve(unsigned c)
        -:  395:    {
        -:  396:        return c == path_cmd_curve3 || c == path_cmd_curve4;
        -:  397:    }
        -:  398:
        -:  399:    //---------------------------------------------------------------is_curve3
        -:  400:    inline bool is_curve3(unsigned c)
        -:  401:    {
        -:  402:        return c == path_cmd_curve3;
        -:  403:    }
        -:  404:
        -:  405:    //---------------------------------------------------------------is_curve4
        -:  406:    inline bool is_curve4(unsigned c)
        -:  407:    {
        -:  408:        return c == path_cmd_curve4;
        -:  409:    }
        -:  410:
        -:  411:    //-------------------------------------------------------------is_end_poly
        -:  412:    inline bool is_end_poly(unsigned c)
        -:  413:    {
        -:  414:        return (c & path_cmd_mask) == path_cmd_end_poly;
        -:  415:    }
        -:  416:
        -:  417:    //----------------------------------------------------------------is_close
        -:  418:    inline bool is_close(unsigned c)
        -:  419:    {
        -:  420:        return (c & ~(path_flags_cw | path_flags_ccw)) ==
        -:  421:               (path_cmd_end_poly | path_flags_close);
        -:  422:    }
        -:  423:
        -:  424:    //------------------------------------------------------------is_next_poly
        -:  425:    inline bool is_next_poly(unsigned c)
        -:  426:    {
        -:  427:        return is_stop(c) || is_move_to(c) || is_end_poly(c);
        -:  428:    }
        -:  429:
        -:  430:    //-------------------------------------------------------------------is_cw
        -:  431:    inline bool is_cw(unsigned c)
        -:  432:    {
        -:  433:        return (c & path_flags_cw) != 0;
        -:  434:    }
        -:  435:
        -:  436:    //------------------------------------------------------------------is_ccw
        -:  437:    inline bool is_ccw(unsigned c)
        -:  438:    {
        -:  439:        return (c & path_flags_ccw) != 0;
        -:  440:    }
        -:  441:
        -:  442:    //-------------------------------------------------------------is_oriented
        -:  443:    inline bool is_oriented(unsigned c)
        -:  444:    {
        -:  445:        return (c & (path_flags_cw | path_flags_ccw)) != 0;
        -:  446:    }
        -:  447:
        -:  448:    //---------------------------------------------------------------is_closed
        -:  449:    inline bool is_closed(unsigned c)
        -:  450:    {
        -:  451:        return (c & path_flags_close) != 0;
        -:  452:    }
        -:  453:
        -:  454:    //----------------------------------------------------------get_close_flag
        -:  455:    inline unsigned get_close_flag(unsigned c)
        -:  456:    {
        -:  457:        return c & path_flags_close;
        -:  458:    }
        -:  459:
        -:  460:    //-------------------------------------------------------clear_orientation
        -:  461:    inline unsigned clear_orientation(unsigned c)
        -:  462:    {
        -:  463:        return c & ~(path_flags_cw | path_flags_ccw);
        -:  464:    }
        -:  465:
        -:  466:    //---------------------------------------------------------get_orientation
        -:  467:    inline unsigned get_orientation(unsigned c)
        -:  468:    {
        -:  469:        return c & (path_flags_cw | path_flags_ccw);
        -:  470:    }
        -:  471:
        -:  472:    //---------------------------------------------------------set_orientation
        -:  473:    inline unsigned set_orientation(unsigned c, unsigned o)
        -:  474:    {
        -:  475:        return clear_orientation(c) | o;
        -:  476:    }
        -:  477:
        -:  478:    //--------------------------------------------------------------point_base
        -:  479:    template<class T> struct point_base
        -:  480:    {
        -:  481:        typedef T value_type;
        -:  482:        T x,y;
function _ZN11agg_fontnik10point_baseIdEC2Ev called 1402233 returned 100% blocks executed 100%
  1402233:  483:        point_base() {}
function _ZN11agg_fontnik10point_baseIdEC2Edd called 74097 returned 100% blocks executed 100%
    74097:  484:        point_base(T x_, T y_) : x(x_), y(y_) {}
        -:  485:    };
        -:  486:    typedef point_base<int>    point_i; //-----point_i
        -:  487:    typedef point_base<float>  point_f; //-----point_f
        -:  488:    typedef point_base<double> point_d; //-----point_d
        -:  489:
        -:  490:    //-------------------------------------------------------------vertex_base
        -:  491:    template<class T> struct vertex_base
        -:  492:    {
        -:  493:        typedef T value_type;
        -:  494:        T x,y;
        -:  495:        unsigned cmd;
        -:  496:        vertex_base() {}
        -:  497:        vertex_base(T x_, T y_, unsigned cmd_) : x(x_), y(y_), cmd(cmd_) {}
        -:  498:    };
        -:  499:    typedef vertex_base<int>    vertex_i; //-----vertex_i
        -:  500:    typedef vertex_base<float>  vertex_f; //-----vertex_f
        -:  501:    typedef vertex_base<double> vertex_d; //-----vertex_d
        -:  502:
        -:  503:    //----------------------------------------------------------------row_info
        -:  504:    template<class T> struct row_info
        -:  505:    {
        -:  506:        int x1, x2;
        -:  507:        T* ptr;
        -:  508:        row_info() {}
        -:  509:        row_info(int x1_, int x2_, T* ptr_) : x1(x1_), x2(x2_), ptr(ptr_) {}
        -:  510:    };
        -:  511:
        -:  512:    //----------------------------------------------------------const_row_info
        -:  513:    template<class T> struct const_row_info
        -:  514:    {
        -:  515:        int x1, x2;
        -:  516:        const T* ptr;
        -:  517:        const_row_info() {}
        -:  518:        const_row_info(int x1_, int x2_, const T* ptr_) :
        -:  519:            x1(x1_), x2(x2_), ptr(ptr_) {}
        -:  520:    };
        -:  521:
        -:  522:    //------------------------------------------------------------is_equal_eps
        -:  523:    template<class T> inline bool is_equal_eps(T v1, T v2, T epsilon)
        -:  524:    {
        -:  525:        return fabs(v1 - v2) <= double(epsilon);
        -:  526:    }
        -:  527:
        -:  528:}
        -:  529:
        -:  530:
        -:  531:#endif
