        -:    0:Source:/home/travis/build/GITSUNWW/node-fontnik/mason_packages/.link/include/gzip/decompress.hpp
        -:    0:Graph:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcno
        -:    0:Data:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <gzip/config.hpp>
        -:    2:
        -:    3:// zlib
        -:    4:#include <zlib.h>
        -:    5:
        -:    6:// std
        -:    7:#include <limits>
        -:    8:#include <stdexcept>
        -:    9:#include <string>
        -:   10:
        -:   11:namespace gzip {
        -:   12:
        -:   13:class Decompressor
        -:   14:{
        -:   15:    std::size_t max_;
        -:   16:
        -:   17:  public:
function _ZN4gzip12DecompressorC2Em called 0 returned 0% blocks executed 0%
    #####:   18:    Decompressor(std::size_t max_bytes = 1000000000) // by default refuse operation if compressed data is > 1GB
    #####:   19:        : max_(max_bytes)
        -:   20:    {
    #####:   21:    }
        -:   22:
        -:   23:    template <typename OutputType>
function _ZNK4gzip12Decompressor10decompressISt6vectorIcSaIcEEEEvRT_PKcm called 0 returned 0% blocks executed 0%
    #####:   24:    void decompress(OutputType& output,
        -:   25:                    const char* data,
        -:   26:                    std::size_t size) const
        -:   27:    {
        -:   28:        z_stream inflate_s;
        -:   29:
    #####:   30:        inflate_s.zalloc = Z_NULL;
    #####:   31:        inflate_s.zfree = Z_NULL;
    #####:   32:        inflate_s.opaque = Z_NULL;
    #####:   33:        inflate_s.avail_in = 0;
    #####:   34:        inflate_s.next_in = Z_NULL;
        -:   35:
        -:   36:        // The windowBits parameter is the base two logarithm of the window size (the size of the history buffer).
        -:   37:        // It should be in the range 8..15 for this version of the library.
        -:   38:        // Larger values of this parameter result in better compression at the expense of memory usage.
        -:   39:        // This range of values also changes the decoding type:
        -:   40:        //  -8 to -15 for raw deflate
        -:   41:        //  8 to 15 for zlib
        -:   42:        // (8 to 15) + 16 for gzip
        -:   43:        // (8 to 15) + 32 to automatically detect gzip/zlib header
    #####:   44:        constexpr int window_bits = 15 + 32; // auto with windowbits of 15
        -:   45:
        -:   46:#pragma GCC diagnostic push
        -:   47:#pragma GCC diagnostic ignored "-Wold-style-cast"
    #####:   48:        if (inflateInit2(&inflate_s, window_bits) != Z_OK)
branch  0 never executed
branch  1 never executed
        -:   49:        {
    #####:   50:            throw std::runtime_error("inflate init failed");
branch  0 never executed
branch  1 never executed
        -:   51:        }
        -:   52:#pragma GCC diagnostic pop
    #####:   53:        inflate_s.next_in = reinterpret_cast<z_const Bytef*>(data);
        -:   54:
        -:   55:#ifdef DEBUG
        -:   56:        // Verify if size (long type) input will fit into unsigned int, type used for zlib's avail_in
    #####:   57:        std::uint64_t size_64 = size * 2;
    #####:   58:        if (size_64 > std::numeric_limits<unsigned int>::max())
branch  0 never executed
branch  1 never executed
        -:   59:        {
    #####:   60:            inflateEnd(&inflate_s);
    #####:   61:            throw std::runtime_error("size arg is too large to fit into unsigned int type x2");
branch  0 never executed
branch  1 never executed
        -:   62:        }
        -:   63:#endif
    #####:   64:        if (size > max_ || (size * 2) > max_)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   65:        {
    #####:   66:            inflateEnd(&inflate_s);
    #####:   67:            throw std::runtime_error("size may use more memory than intended when decompressing");
branch  0 never executed
branch  1 never executed
        -:   68:        }
    #####:   69:        inflate_s.avail_in = static_cast<unsigned int>(size);
    #####:   70:        std::size_t size_uncompressed = 0;
    #####:   71:        do
        -:   72:        {
    #####:   73:            std::size_t resize_to = size_uncompressed + 2 * size;
    #####:   74:            if (resize_to > max_)
branch  0 never executed
branch  1 never executed
        -:   75:            {
    #####:   76:                inflateEnd(&inflate_s);
    #####:   77:                throw std::runtime_error("size of output string will use more memory then intended when decompressing");
branch  0 never executed
branch  1 never executed
        -:   78:            }
    #####:   79:            output.resize(resize_to);
    #####:   80:            inflate_s.avail_out = static_cast<unsigned int>(2 * size);
    #####:   81:            inflate_s.next_out = reinterpret_cast<Bytef*>(&output[0] + size_uncompressed);
    #####:   82:            int ret = inflate(&inflate_s, Z_FINISH);
    #####:   83:            if (ret != Z_STREAM_END && ret != Z_OK && ret != Z_BUF_ERROR)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   84:            {
    #####:   85:                std::string error_msg = inflate_s.msg;
branch  0 never executed
branch  1 never executed
    #####:   86:                inflateEnd(&inflate_s);
branch  0 never executed
branch  1 never executed
    #####:   87:                throw std::runtime_error(error_msg);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   88:            }
        -:   89:
    #####:   90:            size_uncompressed += (2 * size - inflate_s.avail_out);
    #####:   91:        } while (inflate_s.avail_out == 0);
branch  0 never executed
branch  1 never executed
    #####:   92:        inflateEnd(&inflate_s);
    #####:   93:        output.resize(size_uncompressed);
    #####:   94:    }
        -:   95:};
        -:   96:
        -:   97:inline std::string decompress(const char* data, std::size_t size)
        -:   98:{
        -:   99:    Decompressor decomp;
        -:  100:    std::string output;
        -:  101:    decomp.decompress(output, data, size);
        -:  102:    return output;
        -:  103:}
        -:  104:
        -:  105:} // namespace gzip
