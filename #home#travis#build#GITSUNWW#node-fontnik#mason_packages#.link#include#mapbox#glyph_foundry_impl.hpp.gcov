        -:    0:Source:/home/travis/build/GITSUNWW/node-fontnik/mason_packages/.link/include/mapbox/glyph_foundry_impl.hpp
        -:    0:Graph:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcno
        -:    0:Data:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// fontnik
        -:    2:#include "glyph_foundry.hpp"
        -:    3:
        -:    4:#include <agg/agg_curves.h>
        -:    5:#include <agg/agg_curves_impl.hpp>
        -:    6:
        -:    7:// boost
        -:    8:#include <boost/geometry.hpp>
        -:    9:#include <boost/geometry/geometries/point.hpp>
        -:   10:#include <boost/geometry/geometries/box.hpp>
        -:   11:#include <boost/geometry/index/rtree.hpp>
        -:   12:
        -:   13:// std
        -:   14:#include <cmath> // std::sqrt
        -:   15:
        -:   16:namespace bg = boost::geometry;
        -:   17:namespace bgm = bg::model;
        -:   18:namespace bgi = bg::index;
        -:   19:typedef bgm::point<float, 2, bg::cs::cartesian> Point;
        -:   20:typedef bgm::box<Point> Box;
        -:   21:typedef std::vector<Point> Points;
        -:   22:typedef std::vector<Points> Rings;
        -:   23:typedef std::pair<Point, Point> SegmentPair;
        -:   24:typedef std::pair<Box, SegmentPair> SegmentValue;
        -:   25:typedef bgi::rtree<SegmentValue, bgi::rstar<16>> Tree;
        -:   26:
        -:   27:
        -:   28:namespace sdf_glyph_foundry
        -:   29:{
function _ZN17sdf_glyph_foundry4UserC2Ev called 1805 returned 100% blocks executed 100%
function _ZN17sdf_glyph_foundry4UserD2Ev called 1806 returned 100% blocks executed 100%
     3611:   30:    struct User {
        -:   31:        Rings rings;
        -:   32:        Points ring;
        -:   33:    };
        -:   34:
function _ZN17sdf_glyph_foundry9CloseRingERSt6vectorIN5boost8geometry5model5pointIfLm2ENS2_2cs9cartesianEEESaIS7_EE called 3400 returned 100% blocks executed 80%
     3400:   35:    void CloseRing(Points &ring)
        -:   36:    {
     3400:   37:        const Point &first = ring.front();
     3400:   38:        const Point &last = ring.back();
        -:   39:
     3400:   40:        if (first.get<0>() != last.get<0>() ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
     3400:   41:            first.get<1>() != last.get<1>())
        -:   42:        {
    #####:   43:            ring.push_back(first);
    #####:   44:        }
     3400:   45:    }
        -:   46:
function _ZN17sdf_glyph_foundry6MoveToEPK10FT_Vector_Pv called 3399 returned 100% blocks executed 100%
     3399:   47:    int MoveTo(const FT_Vector *to, void *ptr)
        -:   48:    {
     3399:   49:        User *user = (User*)ptr;
     3399:   50:        if (!user->ring.empty()) {
branch  0 taken 51%
branch  1 taken 49%
     1726:   51:            CloseRing(user->ring);
     1726:   52:            user->rings.push_back(user->ring);
     1726:   53:            user->ring.clear();
     1726:   54:        }
     3400:   55:        user->ring.emplace_back(float(to->x) / 64.0, float(to->y) / 64.0);
     3400:   56:        return 0;
        -:   57:    }
        -:   58:
function _ZN17sdf_glyph_foundry6LineToEPK10FT_Vector_Pv called 15822 returned 100% blocks executed 100%
    15822:   59:    int LineTo(const FT_Vector *to, void *ptr)
        -:   60:    {
    15822:   61:        User *user = static_cast<User*>(ptr);
    15822:   62:        user->ring.emplace_back(float(to->x) / 64.0, float(to->y) / 64.0);
    15822:   63:        return 0;
        -:   64:    }
        -:   65:
function _ZN17sdf_glyph_foundry7ConicToEPK10FT_Vector_S2_Pv called 21909 returned 100% blocks executed 83%
    21909:   66:    int ConicTo(const FT_Vector *control,
        -:   67:                const FT_Vector *to,
        -:   68:                void *ptr)
        -:   69:    {
    21909:   70:        User *user = static_cast<User*>(ptr);
        -:   71:
    21909:   72:        if (!user->ring.empty()) {
branch  0 taken 100%
branch  1 taken 0%
    21910:   73:            Point const& prev = user->ring.back();
    21910:   74:            auto dx = prev.get<0>();
    21910:   75:            auto dy = prev.get<1>();
        -:   76:
        -:   77:            // pop off last point, duplicate of first point in bezier curve
        -:   78:            // WARNING: pop_back invalidates `prev`
        -:   79:            // http://en.cppreference.com/w/cpp/container/vector/pop_back
    21910:   80:            user->ring.pop_back();
        -:   81:
    43820:   82:            agg_fontnik::curve3_div curve(dx,dy,
    21910:   83:                                  float(control->x) / 64, float(control->y) / 64,
    21910:   84:                                  float(to->x) / 64, float(to->y) / 64);
        -:   85:
    21910:   86:            curve.rewind(0);
branch  0 taken 100%
branch  1 taken 0%
        -:   87:            double x, y;
        -:   88:            unsigned cmd;
        -:   89:
    96005:   90:            while (agg_fontnik::path_cmd_stop != (cmd = curve.vertex(&x, &y))) {
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 77%
branch  3 taken 23%
    74097:   91:                user->ring.emplace_back(x, y);
branch  0 taken 100%
branch  1 taken 0%
        -:   92:            }
    21910:   93:        }
        -:   94:
    21910:   95:        return 0;
    #####:   96:    }
        -:   97:
function _ZN17sdf_glyph_foundry7CubicToEPK10FT_Vector_S2_S2_Pv called 0 returned 0% blocks executed 0%
    #####:   98:    int CubicTo(const FT_Vector *c1,
        -:   99:                const FT_Vector *c2,
        -:  100:                const FT_Vector *to,
        -:  101:                void *ptr)
        -:  102:    {
    #####:  103:        User *user = static_cast<User*>(ptr);
        -:  104:
    #####:  105:        if (!user->ring.empty()) {
branch  0 never executed
branch  1 never executed
        -:  106:
    #####:  107:            Point const& prev = user->ring.back();
    #####:  108:            auto dx = prev.get<0>();
    #####:  109:            auto dy = prev.get<1>();
        -:  110:
        -:  111:            // pop off last point, duplicate of first point in bezier curve
        -:  112:            // WARNING: pop_back invalidates `prev`
        -:  113:            // http://en.cppreference.com/w/cpp/container/vector/pop_back
    #####:  114:            user->ring.pop_back();
        -:  115:
    #####:  116:            agg_fontnik::curve4_div curve(dx,dy,
    #####:  117:                                  float(c1->x) / 64, float(c1->y) / 64,
    #####:  118:                                  float(c2->x) / 64, float(c2->y) / 64,
    #####:  119:                                  float(to->x) / 64, float(to->y) / 64);
        -:  120:
    #####:  121:            curve.rewind(0);
branch  0 never executed
branch  1 never executed
        -:  122:            double x, y;
        -:  123:            unsigned cmd;
        -:  124:
    #####:  125:            while (agg_fontnik::path_cmd_stop != (cmd = curve.vertex(&x, &y))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:                user->ring.emplace_back(x, y);
branch  0 never executed
branch  1 never executed
        -:  127:            }
    #####:  128:        }
        -:  129:
    #####:  130:        return 0;
    #####:  131:    }
        -:  132:
        -:  133:    // point in polygon ray casting algorithm
function _ZN17sdf_glyph_foundry17PolyContainsPointERKSt6vectorIS0_IN5boost8geometry5model5pointIfLm2ENS2_2cs9cartesianEEESaIS7_EESaIS9_EERKS7_ called 693845 returned 100% blocks executed 100%
   693845:  134:    bool PolyContainsPoint(const Rings &rings, const Point &p)
        -:  135:    {
   693845:  136:        bool c = false;
        -:  137:
  2201713:  138:        for (const Points &ring : rings) {
branch  0 taken 68%
branch  1 taken 32%
  1507826:  139:            auto p1 = ring.begin();
  1507826:  140:            auto p2 = p1 + 1;
        -:  141:
 32455444:  142:            for (; p2 != ring.end(); p1++, p2++) {
branch  0 taken 95%
branch  1 taken 5%
 30934646:  143:                if (((p1->get<1>() > p.get<1>()) != (p2->get<1>() > p.get<1>())) && (p.get<0>() < (p2->get<0>() - p1->get<0>()) * (p.get<1>() - p1->get<1>()) / (p2->get<1>() - p1->get<1>()) + p1->get<0>())) {
branch  0 taken 5%
branch  1 taken 95%
branch  2 taken 50%
branch  3 taken 50%
   818803:  144:                    c = !c;
   818803:  145:                }
 30952101:  146:            }
        -:  147:        }
        -:  148:
   693911:  149:        return c;
        -:  150:    }
        -:  151:
function _ZN17sdf_glyph_foundry15SquaredDistanceERKN5boost8geometry5model5pointIfLm2ENS1_2cs9cartesianEEES8_ called 28805355 returned 100% blocks executed 100%
 28805355:  152:    double SquaredDistance(const Point &v, const Point &w)
        -:  153:    {
 28805355:  154:        const double a = v.get<0>() - w.get<0>();
 28805355:  155:        const double b = v.get<1>() - w.get<1>();
 28805355:  156:        return a * a + b * b;
        -:  157:    }
        -:  158:
function _ZN17sdf_glyph_foundry25ProjectPointOnLineSegmentERKN5boost8geometry5model5pointIfLm2ENS1_2cs9cartesianEEES8_S8_ called 14434406 returned 99% blocks executed 100%
 14434406:  159:    Point ProjectPointOnLineSegment(const Point &p,
        -:  160:                                    const Point &v,
        -:  161:                                    const Point &w)
        -:  162:    {
 14434406:  163:      const double l2 = SquaredDistance(v, w);
 14434406:  164:      if (l2 == 0) return v;
branch  0 taken 1%
branch  1 taken 99%
        -:  165:
 14430905:  166:      const double t = ((p.get<0>() - v.get<0>()) * (w.get<0>() - v.get<0>()) + (p.get<1>() - v.get<1>()) * (w.get<1>() - v.get<1>())) / l2;
 14430905:  167:      if (t < 0) return v;
branch  0 taken 43%
branch  1 taken 57%
  8199802:  168:      if (t > 1) return w;
branch  0 taken 76%
branch  1 taken 24%
        -:  169:
  1986214:  170:      return Point {
  1986214:  171:          v.get<0>() + t * (w.get<0>() - v.get<0>()),
  1986214:  172:          v.get<1>() + t * (w.get<1>() - v.get<1>())
        -:  173:      };
 14435844:  174:    }
        -:  175:
function _ZN17sdf_glyph_foundry28SquaredDistanceToLineSegmentERKN5boost8geometry5model5pointIfLm2ENS1_2cs9cartesianEEES8_S8_ called 14433113 returned 100% blocks executed 100%
 14433113:  176:    double SquaredDistanceToLineSegment(const Point &p,
        -:  177:                                        const Point &v,
        -:  178:                                        const Point &w)
        -:  179:    {
 14433113:  180:        const Point s = ProjectPointOnLineSegment(p, v, w);
 14433113:  181:        return SquaredDistance(p, s);
        -:  182:    }
        -:  183:
function _ZN17sdf_glyph_foundry24MinDistanceToLineSegmentERKN5boost8geometry5index5rtreeISt4pairINS1_5model3boxINS5_5pointIfLm2ENS1_2cs9cartesianEEEEES4_ISA_SA_EENS2_5rstarILm16ELm4ELm4ELm32EEENS2_9indexableISD_EENS2_8equal_toISD_EENS0_9container13new_allocatorISD_EEEERKSA_i called 693907 returned 100% blocks executed 90%
   693907:  184:    double MinDistanceToLineSegment(const Tree &tree,
        -:  185:                                    const Point &p,
        -:  186:                                    int radius)
        -:  187:    {
   693907:  188:        const int squared_radius = radius * radius;
        -:  189:
   693907:  190:        std::vector<SegmentValue> results;
  1387805:  191:        tree.query(bgi::intersects(
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
   693910:  192:            Box{
branch  0 taken 100%
branch  1 taken 0%
   693907:  193:                Point{p.get<0>() - radius, p.get<1>() - radius},
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
   693913:  194:                Point{p.get<0>() + radius, p.get<1>() + radius}
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
        -:  195:            }),
   693356:  196:            std::back_inserter(results));
branch  0 taken 100%
branch  1 taken 0%
        -:  197:
   693442:  198:        double sqaured_distance = std::numeric_limits<double>::infinity();
        -:  199:
 15120802:  200:        for (const auto &value : results) {
branch  0 taken 95%
branch  1 taken 5%
 14434426:  201:            const SegmentPair &segment = value.second;
 28868852:  202:            const double dist = SquaredDistanceToLineSegment(p,
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
 14434426:  203:                                                             segment.first,
 14434426:  204:                                                             segment.second);
 14430882:  205:            if (dist < sqaured_distance && dist < squared_radius) {
branch  0 taken 19%
branch  1 taken 81%
branch  2 taken 92%
branch  3 taken 8%
  2519027:  206:                sqaured_distance = dist;
  2519027:  207:            }
        -:  208:        }
        -:  209:
   693910:  210:        return std::sqrt(sqaured_distance);
   693910:  211:    }
        -:  212:
function _ZN17sdf_glyph_foundry9RenderSDFERNS_10glyph_infoEiifP11FT_FaceRec_ called 1806 returned 100% blocks executed 93%
     1806:  213:    void RenderSDF(glyph_info &glyph,
        -:  214:                         int size,
        -:  215:                         int buffer,
        -:  216:                         float cutoff,
        -:  217:                         FT_Face ft_face)
        -:  218:    {
        -:  219:
     1806:  220:        if (FT_Load_Glyph (ft_face, glyph.glyph_index, FT_LOAD_NO_HINTING)) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  221:            return;
        -:  222:        }
        -:  223:
     1806:  224:        int advance = ft_face->glyph->metrics.horiAdvance / 64;
     1806:  225:        int ascender = ft_face->size->metrics.ascender / 64;
     1806:  226:        int descender = ft_face->size->metrics.descender / 64;
        -:  227:
     1806:  228:        glyph.line_height = ft_face->size->metrics.height;
     1806:  229:        glyph.advance = advance;
     1806:  230:        glyph.ascender = ascender;
     1806:  231:        glyph.descender = descender;
        -:  232:
     1806:  233:        FT_Outline_Funcs func_interface = {
        -:  234:            .move_to = &MoveTo,
        -:  235:            .line_to = &LineTo,
        -:  236:            .conic_to = &ConicTo,
        -:  237:            .cubic_to = &CubicTo,
        -:  238:            .shift = 0,
        -:  239:            .delta = 0
        -:  240:        };
        -:  241:
     1806:  242:        User user;
        -:  243:
     1806:  244:        if (ft_face->glyph->format == FT_GLYPH_FORMAT_OUTLINE) {
branch  0 taken 94%
branch  1 taken 6%
        -:  245:            // Decompose outline into bezier curves and line segments
     1696:  246:            FT_Outline outline = ft_face->glyph->outline;
     1696:  247:            if (FT_Outline_Decompose(&outline, &func_interface, &user)) return;
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  248:
     1697:  249:            if (!user.ring.empty()) {
branch  0 taken 99%
branch  1 taken 1%
     1674:  250:                CloseRing(user.ring);
branch  0 taken 0%
branch  1 taken 100%
     1674:  251:                user.rings.push_back(user.ring);
branch  0 taken 0%
branch  1 taken 100%
     1674:  252:            }
        -:  253:
     1697:  254:            if (user.rings.empty()) {
branch  0 taken 1%
branch  1 taken 99%
       23:  255:                return;
        -:  256:            }
     1674:  257:        } else {
      109:  258:            return;
        -:  259:        }
        -:  260:
        -:  261:        // Calculate the real glyph bbox.
     1674:  262:        double bbox_xmin = std::numeric_limits<double>::infinity(),
     1674:  263:               bbox_ymin = std::numeric_limits<double>::infinity();
        -:  264:
     1674:  265:        double bbox_xmax = -std::numeric_limits<double>::infinity(),
     1674:  266:               bbox_ymax = -std::numeric_limits<double>::infinity();
        -:  267:
     5074:  268:        for (const Points &ring : user.rings) {
branch  0 taken 67%
branch  1 taken 33%
    74809:  269:            for (const Point &point : ring) {
branch  0 taken 95%
branch  1 taken 5%
    71409:  270:                if (point.get<0>() > bbox_xmax) bbox_xmax = point.get<0>();
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 12%
branch  3 taken 88%
branch  4 taken 0%
branch  5 taken 100%
    71409:  271:                if (point.get<0>() < bbox_xmin) bbox_xmin = point.get<0>();
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 15%
branch  3 taken 85%
branch  4 taken 0%
branch  5 taken 100%
    71409:  272:                if (point.get<1>() > bbox_ymax) bbox_ymax = point.get<1>();
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 19%
branch  3 taken 81%
branch  4 taken 0%
branch  5 taken 100%
    71409:  273:                if (point.get<1>() < bbox_ymin) bbox_ymin = point.get<1>();
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 12%
branch  3 taken 88%
branch  4 taken 0%
branch  5 taken 100%
        -:  274:            }
        -:  275:        }
        -:  276:
     1674:  277:        bbox_xmin = std::round(bbox_xmin);
     1674:  278:        bbox_ymin = std::round(bbox_ymin);
     1674:  279:        bbox_xmax = std::round(bbox_xmax);
     1674:  280:        bbox_ymax = std::round(bbox_ymax);
        -:  281:
        -:  282:        // Offset so that glyph outlines are in the bounding box.
     5074:  283:        for (Points &ring : user.rings) {
branch  0 taken 67%
branch  1 taken 33%
    74809:  284:            for (Point &point : ring) {
branch  0 taken 95%
branch  1 taken 5%
    71408:  285:                point.set<0>(point.get<0>() + -bbox_xmin + buffer);
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100%
    71408:  286:                point.set<1>(point.get<1>() + -bbox_ymin + buffer);
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100%
        -:  287:            }
        -:  288:        }
        -:  289:
     1674:  290:        if (bbox_xmax - bbox_xmin == 0 || bbox_ymax - bbox_ymin == 0) return;
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  291:
     1674:  292:        glyph.left = bbox_xmin;
     1674:  293:        glyph.top = bbox_ymax;
     1674:  294:        glyph.width = bbox_xmax - bbox_xmin;
     1674:  295:        glyph.height = bbox_ymax - bbox_ymin;
        -:  296:
     1674:  297:        Tree tree;
branch  0 taken 0%
branch  1 taken 100%
     1674:  298:        float offset = 0.5;
     1674:  299:        int radius = 8;
     1674:  300:        int radius_by_256 = (256 / radius);
        -:  301:
     5074:  302:        for (const Points &ring : user.rings) {
branch  0 taken 67%
branch  1 taken 33%
     3400:  303:            auto p1 = ring.begin();
     3400:  304:            auto p2 = p1 + 1;
        -:  305:
    71408:  306:            for (; p2 != ring.end(); p1++, p2++) {
branch  0 taken 95%
branch  1 taken 5%
    68009:  307:                const int segment_x1 = std::min(p1->get<0>(), p2->get<0>());
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
    68009:  308:                const int segment_x2 = std::max(p1->get<0>(), p2->get<0>());
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
    68008:  309:                const int segment_y1 = std::min(p1->get<1>(), p2->get<1>());
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
    68009:  310:                const int segment_y2 = std::max(p1->get<1>(), p2->get<1>());
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
        -:  311:
    68009:  312:                tree.insert(SegmentValue {
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
    67974:  313:                    Box {
branch  0 taken 100%
branch  1 taken 0%
    68009:  314:                        Point {segment_x1, segment_y1},
branch  0 taken 100%
branch  1 taken 0%
    68009:  315:                        Point {segment_x2, segment_y2}
branch  0 taken 100%
branch  1 taken 0%
        -:  316:                    },
    68009:  317:                    SegmentPair {
branch  0 taken 100%
branch  1 taken 0%
    68009:  318:                        Point {p1->get<0>(), p1->get<1>()},
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
    68009:  319:                        Point {p2->get<0>(), p2->get<1>()}
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
        -:  320:                    }
        -:  321:                });
    68005:  322:            }
        -:  323:        }
        -:  324:
        -:  325:        // Loop over every pixel and determine the positive/negative distance to the outline.
     1674:  326:        unsigned int buffered_width = glyph.width + 2 * buffer;
     1674:  327:        unsigned int buffered_height = glyph.height + 2 * buffer;
     1674:  328:        unsigned int bitmap_size = buffered_width * buffered_height;
     1674:  329:        glyph.bitmap.resize(bitmap_size);
branch  0 taken 0%
branch  1 taken 100%
        -:  330:
    40511:  331:        for (unsigned int y = 0; y < buffered_height; y++) {
branch  0 taken 96%
branch  1 taken 4%
   732738:  332:            for (unsigned int x = 0; x < buffered_width; x++) {
branch  0 taken 95%
branch  1 taken 5%
   693900:  333:                unsigned int ypos = buffered_height - y - 1;
   693900:  334:                unsigned int i = ypos * buffered_width + x;
   693900:  335:                Point pt{x + offset, y + offset };
branch  0 taken 0%
branch  1 taken 100%
   693909:  336:                double d = MinDistanceToLineSegment(tree, pt, radius) * radius_by_256;
branch  0 taken 0%
branch  1 taken 100%
        -:  337:
        -:  338:                // Invert if point is inside.
   693876:  339:                const bool inside = PolyContainsPoint(user.rings, pt);
branch  0 taken 0%
branch  1 taken 100%
   693909:  340:                if (inside) {
branch  0 taken 18%
branch  1 taken 82%
   123812:  341:                    d = -d;
   123812:  342:                }
        -:  343:
        -:  344:                // Shift the 0 so that we can fit a few negative values
        -:  345:                // into our 8 bits.
   693906:  346:                d += cutoff * 256;
        -:  347:
        -:  348:                // Clamp to 0-255 to prevent overflows or underflows.
   693906:  349:                int n = d > 255 ? 255 : d;
branch  0 taken 4%
branch  1 taken 96%
   693912:  350:                n = n < 0 ? 0 : n;
branch  0 taken 1%
branch  1 taken 99%
        -:  351:
   693912:  352:                glyph.bitmap[i] = static_cast<char>(255 - n);
branch  0 taken 0%
branch  1 taken 100%
   693906:  353:            }
    38838:  354:        }
     1806:  355:    }
branch  0 taken 0%
branch  1 taken 100%
branch  2 taken 0%
        -:  356:
        -:  357:} // ns sdf_glyph_foundry
