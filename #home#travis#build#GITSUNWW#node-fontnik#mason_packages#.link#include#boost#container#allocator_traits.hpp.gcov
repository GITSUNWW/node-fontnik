        -:    0:Source:/home/travis/build/GITSUNWW/node-fontnik/mason_packages/.link/include/boost/container/allocator_traits.hpp
        -:    0:Graph:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcno
        -:    0:Data:/home/travis/build/GITSUNWW/node-fontnik/build/Debug/obj.target/fontnik/src/glyphs.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3:// (C) Copyright Pablo Halpern 2009. Distributed under the Boost
        -:    4:// Software License, Version 1.0. (See accompanying file
        -:    5:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    6://
        -:    7://////////////////////////////////////////////////////////////////////////////
        -:    8://
        -:    9:// (C) Copyright Ion Gaztanaga 2011-2013. Distributed under the Boost
        -:   10:// Software License, Version 1.0. (See accompanying file
        -:   11:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:   12://
        -:   13:// See http://www.boost.org/libs/container for documentation.
        -:   14://
        -:   15://////////////////////////////////////////////////////////////////////////////
        -:   16:#ifndef BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP
        -:   17:#define BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP
        -:   18:
        -:   19:#ifndef BOOST_CONFIG_HPP
        -:   20:#  include <boost/config.hpp>
        -:   21:#endif
        -:   22:
        -:   23:#if defined(BOOST_HAS_PRAGMA_ONCE)
        -:   24:#  pragma once
        -:   25:#endif
        -:   26:
        -:   27:#include <boost/container/detail/config_begin.hpp>
        -:   28:#include <boost/container/detail/workaround.hpp>
        -:   29:
        -:   30:// container
        -:   31:#include <boost/container/container_fwd.hpp>
        -:   32:#include <boost/container/detail/mpl.hpp>
        -:   33:#include <boost/container/detail/type_traits.hpp>  //is_empty
        -:   34:#include <boost/container/detail/placement_new.hpp>
        -:   35:#ifndef BOOST_CONTAINER_DETAIL_STD_FWD_HPP
        -:   36:#include <boost/container/detail/std_fwd.hpp>
        -:   37:#endif
        -:   38:// intrusive
        -:   39:#include <boost/intrusive/pointer_traits.hpp>
        -:   40:#include <boost/intrusive/detail/mpl.hpp>
        -:   41:// move
        -:   42:#include <boost/move/utility_core.hpp>
        -:   43:// move/detail
        -:   44:#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:   45:#include <boost/move/detail/fwd_macros.hpp>
        -:   46:#endif
        -:   47:// other boost
        -:   48:#include <boost/static_assert.hpp>
        -:   49:
        -:   50:#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   51:
        -:   52:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME allocate
        -:   53:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   54:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   55:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 2
        -:   56:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 2
        -:   57:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   58:
        -:   59:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME destroy
        -:   60:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   61:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   62:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:   63:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 1
        -:   64:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   65:
        -:   66:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME construct
        -:   67:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   68:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   69:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:   70:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 9
        -:   71:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   72:
        -:   73:#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   74:
        -:   75:namespace boost {
        -:   76:namespace container {
        -:   77:
        -:   78:#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   79:
        -:   80:template<class Allocator>
        -:   81:class small_vector_allocator;
        -:   82:
        -:   83:namespace allocator_traits_detail {
        -:   84:
        -:   85:BOOST_INTRUSIVE_HAS_STATIC_MEMBER_FUNC_SIGNATURE(has_max_size, max_size)
        -:   86:BOOST_INTRUSIVE_HAS_STATIC_MEMBER_FUNC_SIGNATURE(has_select_on_container_copy_construction, select_on_container_copy_construction)
        -:   87:
        -:   88:}  //namespace allocator_traits_detail {
        -:   89:
        -:   90:namespace dtl {
        -:   91:
        -:   92://workaround needed for C++03 compilers with no construct()
        -:   93://supporting rvalue references
        -:   94:template<class Allocator>
        -:   95:struct is_std_allocator
        -:   96:{  static const bool value = false; };
        -:   97:
        -:   98:template<class T>
        -:   99:struct is_std_allocator< std::allocator<T> >
        -:  100:{  static const bool value = true; };
        -:  101:
        -:  102:template<class T>
        -:  103:struct is_std_allocator< small_vector_allocator< std::allocator<T> > >
        -:  104:{  static const bool value = true; };
        -:  105:
        -:  106:template<class Allocator>
        -:  107:struct is_not_std_allocator
        -:  108:{  static const bool value = !is_std_allocator<Allocator>::value; };
        -:  109:
        -:  110:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(pointer)
        -:  111:BOOST_INTRUSIVE_INSTANTIATE_EVAL_DEFAULT_TYPE_TMPLT(const_pointer)
        -:  112:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(reference)
        -:  113:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(const_reference)
        -:  114:BOOST_INTRUSIVE_INSTANTIATE_EVAL_DEFAULT_TYPE_TMPLT(void_pointer)
        -:  115:BOOST_INTRUSIVE_INSTANTIATE_EVAL_DEFAULT_TYPE_TMPLT(const_void_pointer)
        -:  116:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(size_type)
        -:  117:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(propagate_on_container_copy_assignment)
        -:  118:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(propagate_on_container_move_assignment)
        -:  119:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(propagate_on_container_swap)
        -:  120:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(is_always_equal)
        -:  121:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(difference_type)
        -:  122:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(is_partially_propagable)
        -:  123:
        -:  124:}  //namespace dtl {
        -:  125:
        -:  126:#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:  127:
        -:  128://! The class template allocator_traits supplies a uniform interface to all allocator types.
        -:  129://! This class is a C++03-compatible implementation of std::allocator_traits
        -:  130:template <typename Allocator>
        -:  131:struct allocator_traits
        -:  132:{
        -:  133:   //allocator_type
        -:  134:   typedef Allocator allocator_type;
        -:  135:   //value_type
        -:  136:   typedef typename allocator_type::value_type value_type;
        -:  137:
        -:  138:   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  139:      //! Allocator::pointer if such a type exists; otherwise, value_type*
        -:  140:      //!
        -:  141:      typedef unspecified pointer;
        -:  142:      //! Allocator::const_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<const
        -:  143:      //!
        -:  144:      typedef see_documentation const_pointer;
        -:  145:      //! Non-standard extension
        -:  146:      //! Allocator::reference if such a type exists; otherwise, value_type&
        -:  147:      typedef see_documentation reference;
        -:  148:      //! Non-standard extension
        -:  149:      //! Allocator::const_reference if such a type exists ; otherwise, const value_type&
        -:  150:      typedef see_documentation const_reference;
        -:  151:      //! Allocator::void_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<void>.
        -:  152:      //!
        -:  153:      typedef see_documentation void_pointer;
        -:  154:      //! Allocator::const_void_pointer if such a type exists ; otherwis e, pointer_traits<pointer>::rebind<const
        -:  155:      //!
        -:  156:      typedef see_documentation const_void_pointer;
        -:  157:      //! Allocator::difference_type if such a type exists ; otherwise, pointer_traits<pointer>::difference_type.
        -:  158:      //!
        -:  159:      typedef see_documentation difference_type;
        -:  160:      //! Allocator::size_type if such a type exists ; otherwise, make_unsigned<difference_type>::type
        -:  161:      //!
        -:  162:      typedef see_documentation size_type;
        -:  163:      //! Allocator::propagate_on_container_copy_assignment if such a type exists, otherwise a type
        -:  164:      //! with an internal constant static boolean member <code>value</code> == false.
        -:  165:      typedef see_documentation propagate_on_container_copy_assignment;
        -:  166:      //! Allocator::propagate_on_container_move_assignment if such a type exists, otherwise a type
        -:  167:      //! with an internal constant static boolean member <code>value</code> == false.
        -:  168:      typedef see_documentation propagate_on_container_move_assignment;
        -:  169:      //! Allocator::propagate_on_container_swap if such a type exists, otherwise a type
        -:  170:      //! with an internal constant static boolean member <code>value</code> == false.
        -:  171:      typedef see_documentation propagate_on_container_swap;
        -:  172:      //! Allocator::is_always_equal if such a type exists, otherwise a type
        -:  173:      //! with an internal constant static boolean member <code>value</code> == is_empty<Allocator>::value
        -:  174:      typedef see_documentation is_always_equal;
        -:  175:      //! Allocator::is_partially_propagable if such a type exists, otherwise a type
        -:  176:      //! with an internal constant static boolean member <code>value</code> == false
        -:  177:      //! <b>Note</b>: Non-standard extension used to implement `small_vector_allocator`.
        -:  178:      typedef see_documentation is_partially_propagable;
        -:  179:      //! Defines an allocator: Allocator::rebind<T>::other if such a type exists; otherwise, Allocator<T, Args>
        -:  180:      //! if Allocator is a class template instantiation of the form Allocator<U, Args>, where Args is zero or
        -:  181:      //! more type arguments ; otherwise, the instantiation of rebind_alloc is ill-formed.
        -:  182:      //!
        -:  183:      //! In C++03 compilers <code>rebind_alloc</code> is a struct derived from an allocator
        -:  184:      //! deduced by previously detailed rules.
        -:  185:      template <class T> using rebind_alloc = see_documentation;
        -:  186:
        -:  187:      //! In C++03 compilers <code>rebind_traits</code> is a struct derived from
        -:  188:      //! <code>allocator_traits<OtherAlloc></code>, where <code>OtherAlloc</code> is
        -:  189:      //! the allocator deduced by rules explained in <code>rebind_alloc</code>.
        -:  190:      template <class T> using rebind_traits = allocator_traits<rebind_alloc<T> >;
        -:  191:
        -:  192:      //! Non-standard extension: Portable allocator rebind for C++03 and C++11 compilers.
        -:  193:      //! <code>type</code> is an allocator related to Allocator deduced deduced by rules explained in <code>rebind_alloc</code>.
        -:  194:      template <class T>
        -:  195:      struct portable_rebind_alloc
        -:  196:      {  typedef see_documentation type;  };
        -:  197:   #else
        -:  198:      //pointer
        -:  199:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  200:         pointer, value_type*)
        -:  201:            pointer;
        -:  202:      //const_pointer
        -:  203:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_EVAL_DEFAULT(boost::container::dtl::, Allocator,
        -:  204:         const_pointer, typename boost::intrusive::pointer_traits<pointer>::template
        -:  205:            rebind_pointer<const value_type>)
        -:  206:               const_pointer;
        -:  207:      //reference
        -:  208:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  209:         reference, typename dtl::unvoid_ref<value_type>::type)
        -:  210:            reference;
        -:  211:      //const_reference
        -:  212:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  213:         const_reference, typename dtl::unvoid_ref<const value_type>::type)
        -:  214:               const_reference;
        -:  215:      //void_pointer
        -:  216:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_EVAL_DEFAULT(boost::container::dtl::, Allocator,
        -:  217:         void_pointer, typename boost::intrusive::pointer_traits<pointer>::template
        -:  218:            rebind_pointer<void>)
        -:  219:               void_pointer;
        -:  220:      //const_void_pointer
        -:  221:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_EVAL_DEFAULT(boost::container::dtl::, Allocator,
        -:  222:         const_void_pointer, typename boost::intrusive::pointer_traits<pointer>::template
        -:  223:            rebind_pointer<const void>)
        -:  224:               const_void_pointer;
        -:  225:      //difference_type
        -:  226:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  227:         difference_type, std::ptrdiff_t)
        -:  228:            difference_type;
        -:  229:      //size_type
        -:  230:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  231:         size_type, std::size_t)
        -:  232:            size_type;
        -:  233:      //propagate_on_container_copy_assignment
        -:  234:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  235:         propagate_on_container_copy_assignment, dtl::false_type)
        -:  236:            propagate_on_container_copy_assignment;
        -:  237:      //propagate_on_container_move_assignment
        -:  238:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  239:         propagate_on_container_move_assignment, dtl::false_type)
        -:  240:            propagate_on_container_move_assignment;
        -:  241:      //propagate_on_container_swap
        -:  242:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  243:         propagate_on_container_swap, dtl::false_type)
        -:  244:            propagate_on_container_swap;
        -:  245:      //is_always_equal
        -:  246:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  247:         is_always_equal, dtl::is_empty<Allocator>)
        -:  248:            is_always_equal;
        -:  249:      //is_partially_propagable
        -:  250:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  251:         is_partially_propagable, dtl::false_type)
        -:  252:            is_partially_propagable;
        -:  253:
        -:  254:      //rebind_alloc & rebind_traits
        -:  255:      #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
        -:  256:         //C++11
        -:  257:         template <typename T> using rebind_alloc  = typename boost::intrusive::pointer_rebind<Allocator, T>::type;
        -:  258:         template <typename T> using rebind_traits = allocator_traits< rebind_alloc<T> >;
        -:  259:      #else    // #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
        -:  260:         //Some workaround for C++03 or C++11 compilers with no template aliases
        -:  261:         template <typename T>
        -:  262:         struct rebind_alloc : boost::intrusive::pointer_rebind<Allocator,T>::type
        -:  263:         {
        -:  264:            typedef typename boost::intrusive::pointer_rebind<Allocator,T>::type Base;
        -:  265:            #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  266:               template <typename... Args>
        -:  267:               rebind_alloc(BOOST_FWD_REF(Args)... args) : Base(boost::forward<Args>(args)...) {}
        -:  268:            #else    // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  269:               #define BOOST_CONTAINER_ALLOCATOR_TRAITS_REBIND_ALLOC(N) \
        -:  270:               BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N\
        -:  271:               explicit rebind_alloc(BOOST_MOVE_UREF##N) : Base(BOOST_MOVE_FWD##N){}\
        -:  272:               //
        -:  273:               BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_ALLOCATOR_TRAITS_REBIND_ALLOC)
        -:  274:               #undef BOOST_CONTAINER_ALLOCATOR_TRAITS_REBIND_ALLOC
        -:  275:            #endif   // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  276:         };
        -:  277:
        -:  278:         template <typename T>
        -:  279:         struct rebind_traits
        -:  280:            : allocator_traits<typename boost::intrusive::pointer_rebind<Allocator, T>::type>
        -:  281:         {};
        -:  282:      #endif   // #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
        -:  283:
        -:  284:      //portable_rebind_alloc
        -:  285:      template <class T>
        -:  286:      struct portable_rebind_alloc
        -:  287:      {  typedef typename boost::intrusive::pointer_rebind<Allocator, T>::type type;  };
        -:  288:   #endif   //BOOST_CONTAINER_DOXYGEN_INVOKED
        -:  289:
        -:  290:   //! <b>Returns</b>: <code>a.allocate(n)</code>
        -:  291:   //!
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE8allocateERST_m called 7949 returned 100% blocks executed 100%
     7949:  292:   BOOST_CONTAINER_FORCEINLINE static pointer allocate(Allocator &a, size_type n)
     7949:  293:   {  return a.allocate(n);  }
        -:  294:
        -:  295:   //! <b>Returns</b>: <code>a.deallocate(p, n)</code>
        -:  296:   //!
        -:  297:   //! <b>Throws</b>: Nothing
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE10deallocateERST_PSS_m called 7950 returned 100% blocks executed 100%
     7950:  298:   BOOST_CONTAINER_FORCEINLINE static void deallocate(Allocator &a, pointer p, size_type n)
     7950:  299:   {  a.deallocate(p, n);  }
        -:  300:
        -:  301:   //! <b>Effects</b>: calls <code>a.allocate(n, p)</code> if that call is well-formed;
        -:  302:   //! otherwise, invokes <code>a.allocate(n)</code>
        -:  303:   BOOST_CONTAINER_FORCEINLINE static pointer allocate(Allocator &a, size_type n, const_void_pointer p)
        -:  304:   {
        -:  305:      const bool value = boost::container::dtl::
        -:  306:         has_member_function_callable_with_allocate
        -:  307:            <Allocator, const size_type, const const_void_pointer>::value;
        -:  308:      dtl::bool_<value> flag;
        -:  309:      return allocator_traits::priv_allocate(flag, a, n, p);
        -:  310:   }
        -:  311:
        -:  312:   //! <b>Effects</b>: calls <code>a.destroy(p)</code> if that call is well-formed;
        -:  313:   //! otherwise, invokes <code>p->~T()</code>.
        -:  314:   template<class T>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE7destroyISS_EEvRST_PT_ called 7950 returned 100% blocks executed 100%
     7950:  315:   BOOST_CONTAINER_FORCEINLINE static void destroy(Allocator &a, T*p) BOOST_NOEXCEPT_OR_NOTHROW
        -:  316:   {
        -:  317:      typedef T* destroy_pointer;
     7950:  318:      const bool value = boost::container::dtl::
        -:  319:         has_member_function_callable_with_destroy
        -:  320:            <Allocator, const destroy_pointer>::value;
        -:  321:      dtl::bool_<value> flag;
     7950:  322:      allocator_traits::priv_destroy(flag, a, p);
     7950:  323:   }
        -:  324:
        -:  325:   //! <b>Returns</b>: <code>a.max_size()</code> if that expression is well-formed; otherwise,
        -:  326:   //! <code>numeric_limits<size_type>::max()</code>.
        -:  327:   BOOST_CONTAINER_FORCEINLINE static size_type max_size(const Allocator &a) BOOST_NOEXCEPT_OR_NOTHROW
        -:  328:   {
        -:  329:      const bool value = allocator_traits_detail::has_max_size<Allocator, size_type (Allocator::*)() const>::value;
        -:  330:      dtl::bool_<value> flag;
        -:  331:      return allocator_traits::priv_max_size(flag, a);
        -:  332:   }
        -:  333:
        -:  334:   //! <b>Returns</b>: <code>a.select_on_container_copy_construction()</code> if that expression is well-formed;
        -:  335:   //! otherwise, a.
        -:  336:   BOOST_CONTAINER_FORCEINLINE static BOOST_CONTAINER_DOC1ST(Allocator,
        -:  337:      typename dtl::if_c
        -:  338:         < allocator_traits_detail::has_select_on_container_copy_construction<Allocator BOOST_MOVE_I Allocator (Allocator::*)() const>::value
        -:  339:         BOOST_MOVE_I Allocator BOOST_MOVE_I const Allocator & >::type)
        -:  340:   select_on_container_copy_construction(const Allocator &a)
        -:  341:   {
        -:  342:      const bool value = allocator_traits_detail::has_select_on_container_copy_construction
        -:  343:         <Allocator, Allocator (Allocator::*)() const>::value;
        -:  344:      dtl::bool_<value> flag;
        -:  345:      return allocator_traits::priv_select_on_container_copy_construction(flag, a);
        -:  346:   }
        -:  347:
        -:  348:   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  349:      //! <b>Effects</b>: calls <code>a.construct(p, std::forward<Args>(args)...)</code> if that call is well-formed;
        -:  350:      //! otherwise, invokes <code>`placement new` (static_cast<void*>(p)) T(std::forward<Args>(args)...)</code>
        -:  351:      template <class T, class ...Args>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE9constructISS_JSP_EEEvRST_PT_DpOT0_ called 6627 returned 100% blocks executed 100%
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE9constructISS_JSR_EEEvRST_PT_DpOT0_ called 1323 returned 100% blocks executed 100%
     7950:  352:      BOOST_CONTAINER_FORCEINLINE static void construct(Allocator & a, T* p, BOOST_FWD_REF(Args)... args)
        -:  353:      {
        -:  354:         static const bool value = ::boost::move_detail::and_
        -:  355:            < dtl::is_not_std_allocator<Allocator>
        -:  356:            , boost::container::dtl::has_member_function_callable_with_construct
        -:  357:                  < Allocator, T*, Args... >
        -:  358:            >::value;
        -:  359:         dtl::bool_<value> flag;
     7950:  360:         allocator_traits::priv_construct(flag, a, p, ::boost::forward<Args>(args)...);
     7950:  361:      }
        -:  362:   #endif
        -:  363:
        -:  364:   //! <b>Returns</b>: <code>a.storage_is_unpropagable(p)</code> if is_partially_propagable::value is true; otherwise,
        -:  365:   //! <code>false</code>.
        -:  366:   BOOST_CONTAINER_FORCEINLINE static bool storage_is_unpropagable(const Allocator &a, pointer p) BOOST_NOEXCEPT_OR_NOTHROW
        -:  367:   {
        -:  368:      dtl::bool_<is_partially_propagable::value> flag;
        -:  369:      return allocator_traits::priv_storage_is_unpropagable(flag, a, p);
        -:  370:   }
        -:  371:
        -:  372:   //! <b>Returns</b>: <code>true</code> if <code>is_always_equal::value == true</code>, otherwise,
        -:  373:   //! <code>a == b</code>.
        -:  374:   BOOST_CONTAINER_FORCEINLINE static bool equal(const Allocator &a, const Allocator &b) BOOST_NOEXCEPT_OR_NOTHROW
        -:  375:   {
        -:  376:      dtl::bool_<is_always_equal::value> flag;
        -:  377:      return allocator_traits::priv_equal(flag, a, b);
        -:  378:   }
        -:  379:
        -:  380:   #if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  381:   private:
        -:  382:   BOOST_CONTAINER_FORCEINLINE static pointer priv_allocate(dtl::true_type, Allocator &a, size_type n, const_void_pointer p)
        -:  383:   {  return a.allocate(n, p);  }
        -:  384:
        -:  385:   BOOST_CONTAINER_FORCEINLINE static pointer priv_allocate(dtl::false_type, Allocator &a, size_type n, const_void_pointer)
        -:  386:   {  return a.allocate(n);  }
        -:  387:
        -:  388:   template<class T>
        -:  389:   BOOST_CONTAINER_FORCEINLINE static void priv_destroy(dtl::true_type, Allocator &a, T* p) BOOST_NOEXCEPT_OR_NOTHROW
        -:  390:   {  a.destroy(p);  }
        -:  391:
        -:  392:   template<class T>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE12priv_destroyISS_EEvNS_11move_detail17integral_constantIbLb0EEERST_PT_ called 7950 returned 100% blocks executed 100%
     7950:  393:   BOOST_CONTAINER_FORCEINLINE static void priv_destroy(dtl::false_type, Allocator &, T* p) BOOST_NOEXCEPT_OR_NOTHROW
     7950:  394:   {  p->~T(); (void)p;  }
        -:  395:
        -:  396:   BOOST_CONTAINER_FORCEINLINE static size_type priv_max_size(dtl::true_type, const Allocator &a) BOOST_NOEXCEPT_OR_NOTHROW
        -:  397:   {  return a.max_size();  }
        -:  398:
        -:  399:   BOOST_CONTAINER_FORCEINLINE static size_type priv_max_size(dtl::false_type, const Allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  400:   {  return size_type(-1)/sizeof(value_type);  }
        -:  401:
        -:  402:   BOOST_CONTAINER_FORCEINLINE static Allocator priv_select_on_container_copy_construction(dtl::true_type, const Allocator &a)
        -:  403:   {  return a.select_on_container_copy_construction();  }
        -:  404:
        -:  405:   BOOST_CONTAINER_FORCEINLINE static const Allocator &priv_select_on_container_copy_construction(dtl::false_type, const Allocator &a) BOOST_NOEXCEPT_OR_NOTHROW
        -:  406:   {  return a;  }
        -:  407:
        -:  408:   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  409:      template<class T, class ...Args>
        -:  410:      BOOST_CONTAINER_FORCEINLINE static void priv_construct(dtl::true_type, Allocator &a, T *p, BOOST_FWD_REF(Args) ...args)
        -:  411:      {  a.construct( p, ::boost::forward<Args>(args)...);  }
        -:  412:
        -:  413:      template<class T, class ...Args>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE14priv_constructISS_JSP_EEEvNS_11move_detail17integral_constantIbLb0EEERST_PT_DpOT0_ called 6627 returned 100% blocks executed 60%
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS_7variantINS_8geometry5index6detail5rtree12variant_leafISt4pairINS4_5model3boxINSA_5pointIfLm2ENS4_2cs9cartesianEEEEES9_ISF_SF_EENS5_5rstarILm16ELm4ELm4ELm32EEESG_NS7_10allocatorsINS2_ISI_EESI_SK_SG_NS7_23node_variant_static_tagEEESN_EEJNS7_21variant_internal_nodeISI_SK_SG_SO_SN_EEEEEEEE14priv_constructISS_JSR_EEEvNS_11move_detail17integral_constantIbLb0EEERST_PT_DpOT0_ called 1323 returned 100% blocks executed 60%
     7950:  414:      BOOST_CONTAINER_FORCEINLINE static void priv_construct(dtl::false_type, Allocator &, T *p, BOOST_FWD_REF(Args) ...args)
     7950:  415:      {  ::new((void*)p, boost_container_new_t()) T(::boost::forward<Args>(args)...); }
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  416:   #else // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  417:      public:
        -:  418:
        -:  419:      #define BOOST_CONTAINER_ALLOCATOR_TRAITS_CONSTRUCT_IMPL(N) \
        -:  420:      template<class T BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  421:      BOOST_CONTAINER_FORCEINLINE static void construct(Allocator &a, T *p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -:  422:      {\
        -:  423:         static const bool value = ::boost::move_detail::and_ \
        -:  424:            < dtl::is_not_std_allocator<Allocator> \
        -:  425:            , boost::container::dtl::has_member_function_callable_with_construct \
        -:  426:                  < Allocator, T* BOOST_MOVE_I##N BOOST_MOVE_FWD_T##N > \
        -:  427:            >::value; \
        -:  428:         dtl::bool_<value> flag;\
        -:  429:         (priv_construct)(flag, a, p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -:  430:      }\
        -:  431:      //
        -:  432:      BOOST_MOVE_ITERATE_0TO8(BOOST_CONTAINER_ALLOCATOR_TRAITS_CONSTRUCT_IMPL)
        -:  433:      #undef BOOST_CONTAINER_ALLOCATOR_TRAITS_CONSTRUCT_IMPL
        -:  434:
        -:  435:      private:
        -:  436:      /////////////////////////////////
        -:  437:      // priv_construct
        -:  438:      /////////////////////////////////
        -:  439:      #define BOOST_CONTAINER_ALLOCATOR_TRAITS_PRIV_CONSTRUCT_IMPL(N) \
        -:  440:      template<class T BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  441:      BOOST_CONTAINER_FORCEINLINE static void priv_construct(dtl::true_type, Allocator &a, T *p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -:  442:      {  a.construct( p BOOST_MOVE_I##N BOOST_MOVE_FWD##N );  }\
        -:  443:      \
        -:  444:      template<class T BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  445:      BOOST_CONTAINER_FORCEINLINE static void priv_construct(dtl::false_type, Allocator &, T *p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -:  446:      {  ::new((void*)p, boost_container_new_t()) T(BOOST_MOVE_FWD##N); }\
        -:  447:      //
        -:  448:      BOOST_MOVE_ITERATE_0TO8(BOOST_CONTAINER_ALLOCATOR_TRAITS_PRIV_CONSTRUCT_IMPL)
        -:  449:      #undef BOOST_CONTAINER_ALLOCATOR_TRAITS_PRIV_CONSTRUCT_IMPL
        -:  450:
        -:  451:   #endif   // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  452:
        -:  453:   template<class T>
        -:  454:   BOOST_CONTAINER_FORCEINLINE static void priv_construct(dtl::false_type, Allocator &, T *p, const ::boost::container::default_init_t&)
        -:  455:   {  ::new((void*)p, boost_container_new_t()) T; }
        -:  456:
        -:  457:   BOOST_CONTAINER_FORCEINLINE static bool priv_storage_is_unpropagable(dtl::true_type, const Allocator &a, pointer p)
        -:  458:   {  return a.storage_is_unpropagable(p);  }
        -:  459:
        -:  460:   BOOST_CONTAINER_FORCEINLINE static bool priv_storage_is_unpropagable(dtl::false_type, const Allocator &, pointer)
        -:  461:   {  return false;  }
        -:  462:
        -:  463:   BOOST_CONTAINER_FORCEINLINE static bool priv_equal(dtl::true_type,  const Allocator &, const Allocator &)
        -:  464:   {  return true;  }
        -:  465:
        -:  466:   BOOST_CONTAINER_FORCEINLINE static bool priv_equal(dtl::false_type, const Allocator &a, const Allocator &b)
        -:  467:   {  return a == b;  }
        -:  468:
        -:  469:   #endif   //#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  470:};
        -:  471:
        -:  472:}  //namespace container {
        -:  473:}  //namespace boost {
        -:  474:
        -:  475:#include <boost/container/detail/config_end.hpp>
        -:  476:
        -:  477:#endif // ! defined(BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP)
